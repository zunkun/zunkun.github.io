---
title: '3184'
date: '2024-10-22'
udate: '2024-10-22'
---
# 3184. 构成整天的下标对数目 I

## 题目描述
题目链接: [3184. 构成整天的下标对数目 I](https://leetcode.cn/problems/count-pairs-that-form-a-complete-day-i/description/)

给你一个整数数组 hours，表示以 小时 为单位的时间，返回一个整数，表示满足 i < j 且 hours[i] + hours[j] 构成 整天 的下标对 i, j 的数目。

整天 定义为时间持续时间是 24 小时的 整数倍 。

示例 1：
```
输入： hours = [12,12,30,24,24]
输出： 2
解释：
构成整天的下标对分别是 (0, 1) 和 (3, 4)。
```

示例 2：
```
输入： hours = [72,48,24,3]
输出： 3
解释：
构成整天的下标对分别是 (0, 1)、(0, 2) 和 (1, 2)。
```


## 题解
### 方法一：暴力枚举

遍历数组，找到整除24的一对数
```py
class Solution:
  def countCompleteDayPairs(self, hours):
    length = len(hours)

    count = 0

    for i in range(length):
      for j in range(i+1, length):
        if (hours[i] + hours[j]) % 24 == 0:
          count += 1

    return count
```

### 分析：
时间复杂度: $O(n^2)$

空间复杂度: $O(1)$

## 方法二：哈希表分析【错误方法】
LeetCode 上面有很多人贴出了使用 hash 进行排列组合算法， 现在将其贴出来，不要被其迷惑。这个题目还有一点就是`有序对`,下面的解题方法忽略了这点，比如给定输入  `[20,4]` ，这个输入结果会是 `0` ,而不是 `1`

```py

class Solution:
    def countCompleteDayPairs(self, hours: List[int]) -> int:
        cnt = [0] * 24                     # cnt[i]表示模值为i的时间个数
        res = 0
        for h in hours:
            mod = h % 24                   # 计算模值
            res += cnt[(24 - mod) % 24]    # 在哈希表中找到另一个加数，有几个就构成几个下标对
            cnt[mod] += 1                  # 更新这个模值的出现次数
        return res

作者：画图小匠
链接：https://leetcode.cn/problems/count-pairs-that-form-a-complete-day-i/solutions/2960269/javapython3cha-xi-biao-mo-yun-suan-ban-l-s0fh/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```
