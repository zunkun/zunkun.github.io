---
title: 单例模式
date: '2023-02-26'
udate: '2023-02-26'
---

# 单例模式

单例模式（Singleton Pattern）：创建型模式，提供了一种创建对象的最佳方式，这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建

在应用程序运行期间，单例模式只会在全局作用域下创建一次实例对象，让所有需要调用的地方都共享这一单例对象

## 实现

在`javascript`中，实现一个单例模式可以用一个变量来标志当前的类已经创建过对象，如果下次获取当前类的实例时，直接返回之前创建的对象即可，如下：

```js
// 定义一个类
function Singleton(name) {
    this.name = name;
    this.instance = null;
}
// 原型扩展类的一个方法getName()
Singleton.prototype.getName = function() {
    console.log(this.name)
};
// 获取类的实例
Singleton.getInstance = function(name) {
    if(!this.instance) {
        this.instance = new Singleton(name);
    }
    return this.instance
};

// 获取对象1
const a = Singleton.getInstance('a');
// 获取对象2
const b = Singleton.getInstance('b');
// 进行比较
console.log(a === b);
```

### 闭包

```js
function Singleton(name) {
    this.name = name;
}
// 原型扩展类的一个方法getName()
Singleton.prototype.getName = function() {
    console.log(this.name)
};
// 获取类的实例
Singleton.getInstance = (function() {
    var instance = null;
    return function(name) {
        if(!this.instance) {
            this.instance = new Singleton(name);
        }
        return this.instance
    }        
})();

// 获取对象1
const a = Singleton.getInstance('a');
// 获取对象2
const b = Singleton.getInstance('b');
// 进行比较
console.log(a === b);
```

### ES6用法

```js
class Singleton4 {
	constructor(name) {
		this.name = name;
	}

	static getInstance(name) {
		if (!Singleton4.instance) Singleton4.instance = new Singleton4(name);
		return Singleton4.instance;
	}

	getName() {
		return this.name;
	}
}

var e = Singleton4.getInstance('e');
var f = Singleton4.getInstance('f');

console.log(e === f, e.getName(), f.getName());
```

或者如此写法

```js
class Singleton5 {
	constructor(name) {
		if (!Singleton5.instance) {
			this.name = name;
			Singleton5.instance = this;
		}
		return Singleton5.instance;
	}

	getName() {
		return this.name;
	}
}

var g = new Singleton5('g');
var h = new Singleton5('h');

console.log(g === h, g.getName(), h.getName());
```
